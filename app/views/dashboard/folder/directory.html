
{{#folder}}

{{^root}}
{{> close-button}}
{{/root}}

{{#root}}
  <div class="folder-container" style="position:relative;top:-7px">
    <a class="line" href="{{{base}}}/client{{#blog.client}}/{{client.name}}{{/blog.client}}">
      <span class="label">Folder</span>
      {{^blog.client}}
      <span class="link">Sync the folder</span>
      {{/blog.client}}
      {{#blog.client}}
      <span class="center">
        <img width="16" height="16" src="{{#cdn}}/images/sync/{{blog.client}}.svg{{/cdn}}" />
        {{client.display_name}}
        <span class="link" style="margin-left: 12px;">Edit</span>

      </span>
      {{/blog.client}}
    </a>
    <div class="folder-corner"></div>
    <div class="folder-top"></div>
    {{/root}}

    <div class="folder-box {{#root}}root{{/root}} {{#directory}}directory{{/directory}}" style="position:relative;{{^root}}min-height:calc(100vh - 11rem){{/root}}">
    <div class="folder-drop-target" aria-hidden="true" style="display:none;position:absolute;inset:0;z-index:10;align-items:center;justify-content:center;background:rgba(0, 112, 232, 0.08);border:2px dashed rgba(0, 112, 232, 0.6);border-radius:6px;color:var(--text-color);font-weight:600;pointer-events:none;">Drop files to upload</div>
    {{#directory}}
    <table class="directory-list {{^contents.length}}empty{{/contents.length}}">
        <thead style="height: 1.4em;">
          <tr>
            <th>Name</th>
            <th>Date modified</th>
            <th>Size</th>
          </tr>
        </thead>
        <tbody class="live-updates">
      
          {{^contents.length}}
          <tr>
            <td colspan="3" style="vertical-align: middle;">
              <small style="display: flex;flex-grow: 1;
              font-size: 14px;
              text-align: center;{{#directory}}min-height: 300px;{{/directory}}
              color: var(--light-text-color);justify-content: center;">  
                <span style="align-self: center; text-align: center;display: block;">
                  {{#root}}Folder is empty.<br>{{^blog.client}}<a style="display: inline;" href="{{{base}}}/client">Sync the folder</a>{{/blog.client}}{{/root}}
                  {{^root}}There is nothing here.{{/root}}
                </span>
              </small>
            </td>
          </tr>
          {{/contents.length}}
      
          {{#contents}}
          <tr>
            <td>
              <a href="{{{base}}}/folder{{{url}}}" class="{{#directory}}directory{{/directory}} {{#entry}}entry{{/entry}}">
      
            {{#directory}}
            <span class="icon-folder"></span>
            {{/directory}}
            {{^directory}}  
            {{#entry}}    
            <span class="icon-file-check"></span>
            {{/entry}}
            {{^entry}}
            <span class="icon-file"></span>
            {{/entry}}
            {{/directory}}
            <span class="truncate">{{name}}</span></a>
            </td>
            <td data-sort="{{unix}}">{{modified}}</td>
            <td data-sort="{{#directory}}0{{/directory}}{{^directory}}{{bytes}}{{/directory}}">{{#directory}}--{{/directory}}{{^directory}}{{size}}{{/directory}}</td>
          </tr>
          {{/contents}}
        </table>

      <div class="upload-preview-modal" hidden>
        <div class="upload-preview-modal-backdrop" data-upload-modal-close></div>
        <div class="upload-preview-modal-dialog" role="dialog" aria-modal="true" aria-labelledby="upload-preview-title">
          <h2 id="upload-preview-title">Review upload</h2>
          <ul class="upload-preview-list" data-upload-list="queued"></ul>

          <div class="buttons upload-preview-actions">
            <button type="button" data-upload-action="upload">Upload</button>
            <button type="button" data-upload-action="cancel">Cancel</button>
          </div>
        </div>
      </div>
        <script>
          const table = document.querySelector('.directory-list');
          const folderBox = document.querySelector('.folder-box.directory');
          const dropTarget = document.querySelector('.folder-drop-target');
          const uploadModal = document.querySelector('.upload-preview-modal');
          const uploadModalLists = {
            queued: uploadModal && uploadModal.querySelector('[data-upload-list="queued"]')
          };
          const csrfToken = '{{csrftoken}}';
          const currentFolderPrefix = normalizeCurrentFolderPrefix(window.location.pathname);
          
          const state = {
            column: null,
            order: null
          };

          // on page load restore the sort order from local storage
          var storedColumn = localStorage.getItem('sort-column');

          if (storedColumn) state.column = storedColumn;

          var storedOrder = localStorage.getItem('sort-order');

          if (storedOrder) state.order = storedOrder;

          // Restore the width of each column from local storage
          document.querySelectorAll('.directory-list th').forEach(function (th, index) {
            var width = localStorage.getItem('column-width-' + index);
            if (width) {
              th.style.width = width;
              var nextTh = th.nextElementSibling;
              var nextWidth = localStorage.getItem('column-width-' + (index + 1));
              if (nextWidth) {
                nextTh.style.width = nextWidth;
              }
            }
          });
      

          sortTable();
          
           
          function sortTable() {
            
            var order = state.order || 'sorted';
            var column = state.column || 0;

            var reverse = order === 'reverse';
            var header = table.querySelector('th:nth-child(' + (parseInt(column) + 1) + ')');

            var index = Array.from(header.parentNode.children).indexOf(header);
            var rows = Array.from(table.querySelectorAll('tbody tr'));

            if (rows.length === 1 && rows[0].querySelector('td').textContent.trim() === 'Folder is empty.') {
              document.querySelector('.directory-list').classList.add('empty');
            } else {
              document.querySelector('.directory-list').classList.remove('empty');
            }

            if (rows.length < 2) {
              return;
            }

            header.classList.add(order);


            var sorted = rows.sort(function (a, b) {
              var aText = a.children[index].getAttribute('data-sort') ? parseInt(a.children[index].getAttribute('data-sort')) : a.children[index].textContent.toLocaleLowerCase().trim();
              var bText = b.children[index].getAttribute('data-sort') ? parseInt(b.children[index].getAttribute('data-sort')) : b.children[index].textContent.toLocaleLowerCase().trim();
      
              if (reverse) {
                return aText < bText ? 1 : -1;
              } else {
                return aText > bText ? 1 : -1;
              }
            });
      
            table.querySelectorAll('th').forEach(function (th) {
              th.classList.remove('sorted', 'reverse');
            });
      
            header.classList.add('sorted');
            if (reverse) {
              header.classList.add('reverse');
            }
      
            rows.forEach(function (row) {
              row.remove();
            });
      
            sorted.forEach(function (row) {
              table.querySelector('tbody').appendChild(row);
            });
          }

          window.sortTable = sortTable;

          function refreshFolderContents(callback) {
            var xhr = new XMLHttpRequest();

            xhr.onreadystatechange = function () {
              if (xhr.readyState !== 4) return;

              if (xhr.status === 200) {
                var parser = new DOMParser();
                var xml = parser.parseFromString(xhr.responseText, 'text/html');
                var currentNode = document.querySelector('.live-updates');
                var newNode = xml.querySelector('.live-updates');

                if (currentNode && newNode) {
                  currentNode.innerHTML = newNode.innerHTML;
                  sortTable();
                }
              }

              if (typeof callback === 'function') callback();
            };

            xhr.open('GET', window.location.href, true);
            xhr.send();
          }

          function readAllDirectoryEntries(directoryReader) {
            return new Promise(function (resolve, reject) {
              var entries = [];

              function readBatch() {
                directoryReader.readEntries(function (batch) {
                  if (!batch.length) return resolve(entries);
                  entries = entries.concat(Array.from(batch));
                  readBatch();
                }, reject);
              }

              readBatch();
            });
          }

          function collectDroppedFilesFromEntry(entry, parentPath) {
            var basePath = parentPath || '';

            if (entry.isFile) {
              return new Promise(function (resolve, reject) {
                entry.file(function (file) {
                  resolve([{ file: file, relativePath: (basePath + file.name).replace(/^\//, '') }]);
                }, reject);
              });
            }

            if (entry.isDirectory) {
              var nextParent = (basePath + entry.name + '/').replace(/^\//, '');
              var reader = entry.createReader();

              return readAllDirectoryEntries(reader).then(function (entries) {
                return Promise.all(entries.map(function (childEntry) {
                  return collectDroppedFilesFromEntry(childEntry, nextParent);
                })).then(function (nested) {
                  return nested.reduce(function (all, set) {
                    return all.concat(set);
                  }, []);
                });
              });
            }

            return Promise.resolve([]);
          }

          function collectDroppedFiles(dataTransfer) {
            var items = Array.from((dataTransfer && dataTransfer.items) || []);
            var files = Array.from((dataTransfer && dataTransfer.files) || []);

            if (!items.length) {
              return Promise.resolve(files.map(function (file) {
                return { file: file, relativePath: file.name };
              }));
            }

            var hasEntrySupport = items.some(function (item) {
              return item.kind === 'file' && typeof item.webkitGetAsEntry === 'function' && item.webkitGetAsEntry();
            });

            if (!hasEntrySupport) {
              return Promise.resolve(files.map(function (file) {
                return { file: file, relativePath: file.webkitRelativePath || file.name };
              }));
            }

            var tasks = items.map(function (item) {
              if (item.kind !== 'file' || typeof item.webkitGetAsEntry !== 'function') {
                return Promise.resolve([]);
              }

              var entry = item.webkitGetAsEntry();
              if (!entry) return Promise.resolve([]);
              return collectDroppedFilesFromEntry(entry, '');
            });

            return Promise.all(tasks).then(function (sets) {
              return sets.reduce(function (all, set) {
                return all.concat(set);
              }, []);
            });
          }

          function hasFileDragPayload(dataTransfer) {
            if (!dataTransfer) return false;

            var items = Array.from(dataTransfer.items || []);
            if (items.some(function (item) { return item.kind === 'file'; })) {
              return true;
            }

            var types = Array.from(dataTransfer.types || []);
            if (types.some(function (type) { return String(type).toLowerCase() === 'files'; })) {
              return true;
            }

            return Array.from(dataTransfer.files || []).length > 0;
          }

          function isFileDropEvent(event) {
            return !!(event && hasFileDragPayload(event.dataTransfer));
          }

          function showDropTarget() {
            if (dropTarget) {
              dropTarget.style.display = 'flex';
            }
          }

          function hideDropTarget() {
            if (dropTarget) {
              dropTarget.style.display = 'none';
            }
          }

          function normalizeCurrentFolderPrefix(pathname) {
            var path = typeof pathname === 'string' ? pathname : '';
            var marker = '/folder/';
            var folderIndex = path.indexOf(marker);
            var folderPath = '';

            if (folderIndex !== -1) {
              folderPath = path.slice(folderIndex + marker.length);
            } else if (path === '/folder') {
              folderPath = '';
            }

            folderPath = folderPath
              .replace(/\\/g, '/')
              .replace(/^\/+/, '')
              .replace(/\/+$/, '');

            return folderPath ? folderPath + '/' : '';
          }

          function applyCurrentFolderPrefix(relativePath) {
            var normalizedRelativePath = String(relativePath || '')
              .replace(/\\/g, '/')
              .replace(/^\/+/, '');

            return currentFolderPrefix + normalizedRelativePath;
          }

          function buildUploadFormData(collectedFiles, options) {
            var formData = new FormData();
            var relativePaths = [];
            var dryRun = !!(options && options.dryRun);

            collectedFiles.forEach(function (entry, index) {
              var field = 'upload-' + index;
              var relativePath = applyCurrentFolderPrefix(entry.relativePath);

              formData.append(field, entry.file, entry.file.name);
              relativePaths.push({
                field: field,
                index: 0,
                relativePath: relativePath
              });
            });

            formData.append('relativePaths', JSON.stringify(relativePaths));
            formData.append('overwrite', 'true');
            formData.append('dryRun', dryRun ? 'true' : 'false');
            formData.append('_csrf', csrfToken);

            return formData;
          }

          function clearList(list) {
            if (list) list.innerHTML = '';
          }

          function renderList(list, items, mapFn) {
            clearList(list);
            if (!list || !items || !items.length) return;

            items.forEach(function (item) {
              var li = document.createElement('li');

              if (mapFn) {
                var mapped = mapFn(item, li);
                if (typeof mapped === 'string') li.textContent = mapped;
              } else {
                li.innerHTML = `<span class="icon-file-check"></span> ${item}`;
              }

              list.appendChild(li);
            });
          }

          function renderUploadPreview(collectedFiles, preview) {
            var overwritePaths = (preview && preview.overwrite) || [];
            var overwriteSet = new Set(overwritePaths);

            renderList(uploadModalLists.queued, collectedFiles, function (entry, li) {
              li.textContent = entry.relativePath;

              if (overwriteSet.has(entry.relativePath)) {
                var marker = document.createElement('span');
                marker.className = 'upload-preview-overwrite-marker';
                marker.textContent = 'Will overwrite existing file';
                li.appendChild(document.createTextNode(' '));
                li.appendChild(marker);
              }
            });
          }

          function resetUploadModalButtonState() {
            if (!uploadModal || typeof uploadModal.querySelectorAll !== 'function') return;
            Array.from(uploadModal.querySelectorAll('[data-upload-action]')).forEach(function (actionButton) {
              actionButton.disabled = false;
              actionButton.classList.remove('working');
            });
          }

          function openUploadModal() {
            if (!uploadModal) return;
            if (typeof resetUploadModalButtonState === 'function') {
              resetUploadModalButtonState();
            }
            uploadModal.hidden = false;
            document.body.classList.add('upload-modal-open');
          }

          function closeUploadModal() {
            if (!uploadModal) return;
            uploadModal.hidden = true;
            document.body.classList.remove('upload-modal-open');
            if (typeof resetUploadModalButtonState === 'function') {
              resetUploadModalButtonState();
            }
          }

          function collectFailures(result) {
            var failures = [];

            ((result && result.results) || []).forEach(function (entry) {
              if (entry.skipped) {
                failures.push(entry.path + ' — skipped (overwrite disabled)');
              } else if (entry.local && entry.local.success === false) {
                failures.push(entry.path + ' — local write failed: ' + (entry.local.error || 'Unknown error'));
              } else if (entry.client && entry.client.success === false) {
                failures.push(entry.path + ' — remote sync failed: ' + (entry.client.error || 'Unknown error'));
              }
            });

            ((result && result.rejected) || []).forEach(function (entry) {
              var label = entry.relativePath || entry.filename || '(unknown file)';
              failures.push(label + ' — rejected: ' + (entry.reason || 'unknown'));
            });

            return failures;
          }

          function commitUpload(collectedFiles) {
            return fetch('{{{base}}}/folder/upload', {
              method: 'POST',
              body: buildUploadFormData(collectedFiles, { dryRun: false })
            })
              .then(function (response) {
                if (!response.ok) throw new Error('Upload failed');
                return response.json();
              })
              .then(function (result) {
                collectFailures(result);
                closeUploadModal();

                refreshFolderContents();
              });
          }

          function uploadDroppedFiles(collectedFiles) {
            if (!collectedFiles.length) return Promise.resolve();

            var normalizedEntries = collectedFiles.map(function (entry) {
              return {
                file: entry.file,
                relativePath: applyCurrentFolderPrefix(entry.relativePath)
              };
            });

            return fetch('{{{base}}}/folder/upload?dryRun=1', {
              method: 'POST',
              body: buildUploadFormData(normalizedEntries, { dryRun: true })
            })
              .then(function (response) {
                if (!response.ok) throw new Error('Upload dry-run failed');
                return response.json();
              })
              .then(function (preview) {
                renderUploadPreview(normalizedEntries, preview);
                openUploadModal();

                return new Promise(function (resolve, reject) {
                  var finished = false;
                  var isSubmitting = false;

                  function setModalActionButtonsDisabled(disabled) {
                    if (!uploadModal || typeof uploadModal.querySelectorAll !== 'function') return;

                    Array.from(uploadModal.querySelectorAll('[data-upload-action]')).forEach(function (actionButton) {
                      actionButton.disabled = disabled;
                    });
                  }

                  function cleanup() {
                    if (uploadModal) uploadModal.removeEventListener('click', onClick);
                  }

                  function finish(done, value) {
                    if (finished) return;
                    finished = true;
                    cleanup();
                    done(value);
                  }

                  function onClick(event) {
                    if (isSubmitting) return;

                    var close = event.target.closest('[data-upload-modal-close]');
                    if (close) {
                      closeUploadModal();
                      finish(resolve);
                      return;
                    }

                    var button = event.target.closest('[data-upload-action]');
                    if (!button) return;

                    var action = button.getAttribute('data-upload-action');
                    if (action === 'cancel') {
                      closeUploadModal();
                      finish(resolve);
                      return;
                    }

                    if (action !== 'upload') return;

                    isSubmitting = true;
                    setModalActionButtonsDisabled(true);

                    commitUpload(normalizedEntries).then(function () {
                      isSubmitting = false;
                      setModalActionButtonsDisabled(false);
                      finish(resolve);
                    }).catch(function (err) {
                      isSubmitting = false;
                      setModalActionButtonsDisabled(false);
                      finish(reject, err);
                    });
                  }

                  if (uploadModal) {
                    uploadModal.addEventListener('click', onClick);
                  } else {
                    finish(resolve);
                  }
                });
              });
          }

          var dragDepth = 0;

          function resetDropState() {
            dragDepth = 0;
            hideDropTarget();
          }

          window.addEventListener('dragover', function (event) {
            if (isFileDropEvent(event)) {
              event.preventDefault();
            }
          });

          window.addEventListener('drop', function (event) {
            event.preventDefault();

            resetDropState();

            if (!isFileDropEvent(event)) {
              return;
            }

            collectDroppedFiles(event.dataTransfer)
              .then(uploadDroppedFiles)
              .catch(function (error) {
                console.error(error);
              });
          });

          if (folderBox && dropTarget) {
            folderBox.addEventListener('dragenter', function (event) {
              if (!isFileDropEvent(event)) return;
              event.preventDefault();
              dragDepth += 1;
              showDropTarget();
            });

            folderBox.addEventListener('dragover', function (event) {
              if (!isFileDropEvent(event)) return;
              event.preventDefault();
              showDropTarget();
            });

            folderBox.addEventListener('dragleave', function (event) {
              if (!isFileDropEvent(event)) return;
              event.preventDefault();
              dragDepth = Math.max(0, dragDepth - 1);
              if (dragDepth === 0) {
                hideDropTarget();
              }
            });

            folderBox.addEventListener('drop', function (event) {
              event.preventDefault();
              resetDropState();
            });
          }
      
          // add sorting to the directory list
          document.querySelectorAll('.directory-list th').forEach(function (header) {
            header.addEventListener('mousedown', function (event) {
              // ignore clicks on the resize handle
              if (event.target.classList.contains('resize-handle')) {
                return;
              }
      
              var reverse = header.classList.contains('sorted') && !header.classList.contains('reverse');

              state.column = Array.from(header.parentNode.children).indexOf(header);
              state.order = reverse ? 'reverse' : 'sorted';

              sortTable();
      
              localStorage.setItem('sort-column', state.column);
              localStorage.setItem('sort-order', state.order);
            });
          });
      
          // append the node '<span class="resize-handle">|</span>' to each th element
          document.querySelectorAll('.directory-list th:not(:last-child)').forEach(function (th) {
            var handle = document.createElement('span');
            handle.className = 'resize-handle';
            th.appendChild(handle);
          });
      
          // Function to resize columns in the directory list
          document.querySelectorAll('.directory-list th .resize-handle').forEach(function (handle) {
            handle.addEventListener('mousedown', function (event) {
              var th = handle.parentNode;
              var nextTh = th.nextElementSibling;
              var startX = event.clientX;
              var startWidth = th.offsetWidth;
              var tableWidth = th.parentNode.offsetWidth;
      
              document.addEventListener('mousemove', resizeColumn);
              document.addEventListener('mouseup', stopResize);
      
              function resizeColumn(event) {
                var width = startWidth + (event.clientX - startX);
                var currentWidthPercentage = parseFloat(th.style.width.slice(0, -1));
      
                th.style.width = (width / tableWidth) * 100 + '%';
                var widthDeltaInPercentage = (currentWidthPercentage - parseFloat(th.style.width.slice(0, -1)));
                var currentNextWidthPercentage = parseFloat(nextTh.style.width.slice(0, -1));
      
                nextTh.style.width = (currentNextWidthPercentage + widthDeltaInPercentage) + '%';
              }
      
              function stopResize() {
                document.removeEventListener('mousemove', resizeColumn);
                document.removeEventListener('mouseup', stopResize);
      
                // Persist the width of each column in local storage
                var index = Array.from(th.parentNode.children).indexOf(th);
                localStorage.setItem('column-width-' + index, (th.offsetWidth / tableWidth) * 100 + '%');
                localStorage.setItem('column-width-' + (index + 1), (nextTh.offsetWidth / tableWidth) * 100 + '%');
              }
            });
          });
      
      
        </script>
            {{/directory}}

  </div>
{{#blog.client}}
{{#directory}}
<a href="{{{base}}}/client" class="status-link" style="{{^root}}border:1px solid var(--border-color);{{/root}}border-radius: 0 0 6px 6px;">
  {{> sync-status}}
</a>
{{/directory}}
{{/blog.client}}
</div>
{{/folder}}
